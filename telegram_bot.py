#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ü§ñ Bot do Telegram - Sistema Gigante 4GB com Telethon
Todas as funcionalidades do painel em vers√£o bot
Usando apenas a nuvem do Telegram - sem RAM/mem√≥ria local
"""

import os
import logging
import re
import io
import zipfile
import rarfile
import asyncio
import tempfile
from urllib.parse import urlparse
from datetime import datetime
from telethon import TelegramClient, events, Button
from telethon.tl.types import DocumentAttributeFilename
import time

# Configura√ß√µes de logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ========== CONFIGURA√á√ïES DO BOT TELETHON ==========
# Credenciais obtidas das vari√°veis de ambiente
API_ID = os.environ.get("API_ID")
API_HASH = os.environ.get("API_HASH") 
BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
ADMIN_ID = os.environ.get("ADMIN_ID", "123456789")  # ID do admin

if not all([API_ID, API_HASH, BOT_TOKEN]):
    logger.error("‚ùå Configura√ß√µes faltando! Configure: API_ID, API_HASH, TELEGRAM_BOT_TOKEN")
    exit(1)

try:
    api_id_int = int(API_ID)
except (ValueError, TypeError):
    logger.error("‚ùå API_ID deve ser um n√∫mero!")
    exit(1)

# Cliente Telethon
bot = TelegramClient('bot', api_id_int, API_HASH)

# Controle do painel web
painel_ativo = False

# ========== FUN√á√ïES DE FILTRAGEM (do painel original) ==========

def detectar_url_brasileira(url):
    """
    Detecta URLs brasileiras (.br + sites nacionais conhecidos)
    IGUAL AO PAINEL ORIGINAL
    """
    url_lower = url.lower()
    
    # URLs .br diretas
    if '.br' in url_lower:
        return True
    
    # Sites brasileiros .com/.net conhecidos (LISTA EXPANDIDA DO PAINEL)
    sites_br_conhecidos = [
        # Bancos
        'itau.com', 'bradesco.com', 'bb.com', 'santander.com',
        'sicoob.com', 'sicredi.com', 'banrisul.com', 'caixa.gov',
        'bndes.gov', 'bcb.gov', 'nubank.com', 'inter.co',
        
        # E-commerce
        'mercadolivre.com', 'americanas.com', 'magazineluiza.com',
        'casasbahia.com', 'extra.com', 'pontofrio.com',
        'submarino.com', 'shoptime.com', 'netshoes.com',
        'dafiti.com', 'kanui.com', 'centauro.com',
        
        # Tecnologia e Comunica√ß√£o
        'uol.com', 'globo.com', 'terra.com', 'ig.com',
        'bol.com', 'zipmail.com', 'hotmail.com',
        'vivo.com', 'tim.com', 'claro.com', 'oi.com',
        
        # Governo e Servi√ßos
        'correios.com', 'anatel.gov', 'receita.fazenda.gov',
        'detran.', 'tjsp.jus', 'tjrj.jus', 'jus.com',
        'gov.br', 'inss.gov', 'caixa.gov', 'serpro.gov',
        
        # Outros populares
        'abril.com', 'folha.com', 'estadao.com', 'r7.com',
        'band.com', 'sbt.com', 'record.com', 'globoplay.com'
    ]
    
    return any(site in url_lower for site in sites_br_conhecidos)

def linha_valida(linha):
    """
    Valida se linha tem formato de credencial v√°lido
    IGUAL AO PAINEL ORIGINAL
    """
    if not linha or len(linha) < 5:
        return False
    
    # Conta dois pontos na linha
    count_dois_pontos = linha.count(':')
    if count_dois_pontos < 2:
        return False
    
    # Verifica se n√£o √© s√≥ caracteres especiais
    if re.match(r'^[^a-zA-Z0-9]*$', linha):
        return False
    
    return True

def filtrar_spam_divulgacao(linha):
    """
    Remove linhas de spam e divulga√ß√£o, deixando s√≥ URL:USER:PASS
    FILTROS IGUAIS AO PAINEL ORIGINAL
    """
    linha_lower = linha.lower()
    
    # Lista de termos de spam/divulga√ß√£o para remover (DO PAINEL)
    termos_spam = [
        # Divulga√ß√£o comum
        'telegram.me', 'telegram.org', 't.me', '@', 'canal', 'grupo',
        'divulga', 'vendas', 'contato', 'whatsapp', 'zap',
        
        # Nomes/apelidos
        'admin', 'moderador', 'vendedor', 'hacker', 'cracker',
        'owner', 'dono', 'chefe', 'boss', 'master',
        
        # Propaganda
        'comprar', 'vender', 'barato', 'promo', 'desconto',
        'gratis', 'free', 'premium', 'vip', 'exclusivo',
        
        # Links promocionais
        'bit.ly', 'tinyurl', 'encurtador', 'link',
        'acesse', 'clique', 'download', 'baixar',
        
        # Textos promocionais
        'melhor', 'top', 'qualidade', 'confiavel', 'seguro',
        'rapido', 'facil', 'simples', 'garantido',
        
        # Termos de hack
        'combo', 'list', 'lista', 'pack', 'pacote',
        'fresh', 'novo', 'updated', 'atualizado'
    ]
    
    # Se cont√©m termos de spam, remove a linha
    for termo in termos_spam:
        if termo in linha_lower:
            return None
    
    # Se n√£o √© formato URL:USER:PASS, remove
    if not linha_valida(linha):
        return None
    
    return linha.strip()

def processar_credencial(linha):
    """
    Processa uma linha de credencial e extrai dados
    IGUAL AO PAINEL ORIGINAL
    """
    linha_limpa = linha.strip()
    
    # Filtra spam primeiro
    linha_filtrada = filtrar_spam_divulgacao(linha_limpa)
    if not linha_filtrada:
        return None
    
    try:
        # Separa por dois pontos
        partes = linha_filtrada.split(':')
        
        # Formato: http://site.com:user:pass
        if linha_filtrada.startswith(('https://', 'http://')):
            if len(partes) >= 3:
                url = ':'.join(partes[:-2])
                username = partes[-2]
                password = partes[-1]
            else:
                return None
        # Formato: site.com:user:pass
        else:
            if len(partes) >= 3:
                url = partes[0]
                username = partes[1]
                password = partes[2]
            else:
                return None
        
        # Valida√ß√µes b√°sicas
        if not all([url, username, password]):
            return None
        
        if len(username) < 2 or len(password) < 2:
            return None
        
        # Retorna dados estruturados
        return {
            'url': url.strip(),
            'username': username.strip(),
            'password': password.strip(),
            'linha_completa': linha_filtrada,
            'is_brazilian': detectar_url_brasileira(url)
        }
    
    except Exception:
        return None

# ========== PROCESSAMENTO DE ARQUIVOS ==========

async def processar_arquivo_texto(content, filename, chat_id):
    """
    Processa arquivo de texto com filtragem completa
    USANDO APENAS NUVEM DO TELEGRAM - SEM RAM LOCAL
    """
    try:
        # Decodifica content
        if isinstance(content, bytes):
            text_content = content.decode('utf-8', errors='ignore')
        else:
            text_content = content
        
        lines = text_content.split('\n')
        
        credenciais_validas = []
        credenciais_br = []
        stats = {
            'total_lines': len(lines),
            'valid_lines': 0,
            'brazilian_lines': 0,
            'spam_removed': 0
        }
        
        # Processa cada linha
        for linha in lines:
            if not linha.strip():
                continue
            
            # Processa credencial
            credencial = processar_credencial(linha)
            
            if credencial:
                credenciais_validas.append(credencial['linha_completa'])
                stats['valid_lines'] += 1
                
                # Se √© brasileira, adiciona √† lista BR
                if credencial['is_brazilian']:
                    credenciais_br.append(credencial['linha_completa'])
                    stats['brazilian_lines'] += 1
            else:
                stats['spam_removed'] += 1
        
        return credenciais_validas, credenciais_br, stats
    
    except Exception as e:
        logger.error(f"Erro no processamento: {e}")
        return [], [], {'total_lines': 0, 'valid_lines': 0, 'brazilian_lines': 0, 'spam_removed': 0}

async def processar_arquivo_zip(content, filename, chat_id):
    """
    Processa arquivo ZIP com m√∫ltiplos TXTs
    """
    try:
        with zipfile.ZipFile(io.BytesIO(content), 'r') as zip_file:
            todas_credenciais = []
            todas_br = []
            stats_total = {'total_lines': 0, 'valid_lines': 0, 'brazilian_lines': 0, 'spam_removed': 0}
            
            for file_info in zip_file.filelist:
                if file_info.filename.lower().endswith('.txt'):
                    with zip_file.open(file_info) as txt_file:
                        txt_content = txt_file.read()
                        
                        credenciais, br_creds, stats = await processar_arquivo_texto(
                            txt_content, f"{filename}:{file_info.filename}", chat_id
                        )
                        
                        todas_credenciais.extend(credenciais)
                        todas_br.extend(br_creds)
                        
                        # Soma estat√≠sticas
                        for key in stats_total:
                            stats_total[key] += stats[key]
            
            return todas_credenciais, todas_br, stats_total
    
    except Exception as e:
        logger.error(f"Erro no ZIP: {e}")
        return [], [], {'total_lines': 0, 'valid_lines': 0, 'brazilian_lines': 0, 'spam_removed': 0}

async def processar_arquivo_rar(content, filename, chat_id):
    """
    Processa arquivo RAR com m√∫ltiplos TXTs
    """
    try:
        # Salva temporariamente (necess√°rio para rarfile)
        temp_path = os.path.join(tempfile.gettempdir(), f"temp_{int(time.time())}.rar")
        with open(temp_path, 'wb') as f:
            f.write(content)
        
        todas_credenciais = []
        todas_br = []
        stats_total = {'total_lines': 0, 'valid_lines': 0, 'brazilian_lines': 0, 'spam_removed': 0}
        
        with rarfile.RarFile(temp_path, 'r') as rar_file:
            for file_info in rar_file.namelist():
                if file_info.lower().endswith('.txt'):
                    with rar_file.open(file_info) as txt_file:
                        txt_content = txt_file.read()
                        
                        credenciais, br_creds, stats = await processar_arquivo_texto(
                            txt_content, f"{filename}:{file_info}", chat_id
                        )
                        
                        todas_credenciais.extend(credenciais)
                        todas_br.extend(br_creds)
                        
                        # Soma estat√≠sticas
                        for key in stats_total:
                            stats_total[key] += stats[key]
        
        # Remove arquivo tempor√°rio
        if 'temp_path' in locals() and os.path.exists(temp_path):
            os.remove(temp_path)
        
        return todas_credenciais, todas_br, stats_total
    
    except Exception as e:
        logger.error(f"Erro no RAR: {e}")
        # Remove arquivo tempor√°rio se existir
        try:
            if 'temp_path' in locals() and temp_path and os.path.exists(temp_path):
                os.remove(temp_path)
        except:
            pass
        return [], [], {'total_lines': 0, 'valid_lines': 0, 'brazilian_lines': 0, 'spam_removed': 0}

# ========== FUN√á√ïES DE ENVIO DE RESULTADOS ==========

async def enviar_resultado_como_arquivo(chat_id, credenciais, tipo, stats):
    """
    Envia resultado como arquivo na nuvem do Telegram
    """
    if not credenciais:
        await bot.send_message(chat_id, f"‚ùå Nenhuma credencial {tipo} encontrada.")
        return
    
    # Cria conte√∫do do arquivo
    content = '\n'.join(credenciais)
    
    # Nome do arquivo com timestamp
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"credenciais_{tipo}_{timestamp}.txt"
    
    # Envia como arquivo
    await bot.send_file(
        chat_id,
        io.BytesIO(content.encode('utf-8')),
        attributes=[DocumentAttributeFilename(filename)],
        caption=f"üìÅ **{filename}**\n\n"
               f"‚úÖ {len(credenciais):,} credenciais {tipo}\n"
               f"üìä Taxa: {(stats['valid_lines']/max(1,stats['total_lines'])*100):.1f}%"
    )

# ========== HANDLERS DO BOT ==========

@bot.on(events.NewMessage(pattern=r'/start'))
async def start_handler(event):
    """Handler do comando /start"""
    user = await event.get_sender()
    welcome_text = f"""
ü§ñ **Bot Processador Gigante 4GB - Telethon**

Ol√° {user.first_name}! üëã

üöÄ **Todas as fun√ß√µes do painel em bot:**
‚Ä¢ Processamento de arquivos TXT, ZIP e RAR at√© 4GB
‚Ä¢ Filtragem autom√°tica de spam e divulga√ß√£o  
‚Ä¢ Detec√ß√£o de URLs brasileiras expandida
‚Ä¢ Uso apenas da nuvem do Telegram (sem RAM local)

üì§ **Como usar:**
1. Digite `/adicionar` para iniciar
2. Encaminhe seus arquivos TXT/ZIP/RAR
3. Receba os resultados filtrados automaticamente

üáßüá∑ **Filtros implementados:**
‚Ä¢ Remove spam, divulga√ß√£o, nomes, propaganda
‚Ä¢ Detecta sites brasileiros (.br + nacionais .com/.net)
‚Ä¢ Mant√©m apenas formato URL:USER:PASS limpo
‚Ä¢ Filtragem igual ao painel original

Digite `/adicionar` para come√ßar!
    """
    
    await event.reply(welcome_text)

@bot.on(events.NewMessage(pattern=r'/adicionar'))
async def adicionar_handler(event):
    """Handler do comando /adicionar"""
    await event.reply(
        "üì§ **Modo Adi√ß√£o Ativado!**\n\n"
        "Agora envie seus arquivos:\n"
        "‚Ä¢ üìÑ TXT - Arquivos de texto\n"
        "‚Ä¢ üì¶ ZIP - Compactados ZIP\n" 
        "‚Ä¢ üì¶ RAR - Compactados RAR\n\n"
        "‚ö° **Processamento autom√°tico:**\n"
        "‚Ä¢ Filtragem de spam/divulga√ß√£o\n"
        "‚Ä¢ Detec√ß√£o de URLs brasileiras\n"
        "‚Ä¢ Resultado limpo URL:USER:PASS\n\n"
        "üîÑ Envie quantos arquivos quiser!"
    )

@bot.on(events.NewMessage)
async def document_handler(event):
    """Handler para documentos enviados"""
    if not event.document:
        return
    
    # Verifica se tem filename
    filename = None
    for attr in event.document.attributes:
        if hasattr(attr, 'file_name'):
            filename = attr.file_name
            break
    
    if not filename:
        return
    
    # Verifica formato suportado
    if not filename.lower().endswith(('.txt', '.zip', '.rar')):
        await event.reply("‚ùå Formato n√£o suportado! Use apenas TXT, ZIP ou RAR.")
        return
    
    # Verifica tamanho (limite Telegram: 2GB para bots)
    file_size = event.document.size
    if file_size > 2 * 1024 * 1024 * 1024:  # 2GB
        await event.reply(
            "‚ùå Arquivo muito grande!\n"
            "Limite: 2GB\n"
            "Divida em partes menores."
        )
        return
    
    # Mensagem de processamento
    processing_msg = await event.reply(
        f"üöÄ **Processando:** `{filename}`\n"
        f"üìè **Tamanho:** {file_size / 1024 / 1024:.1f} MB\n"
        f"‚è≥ **Aguarde...** Filtrando spam e detectando URLs brasileiras..."
    )
    
    try:
        # Download do arquivo da nuvem do Telegram
        file_content = await event.download_media(bytes)
        
        # Inicializa vari√°veis
        credenciais = []
        br_creds = []
        stats = {'total_lines': 0, 'valid_lines': 0, 'brazilian_lines': 0, 'spam_removed': 0}
        
        # Processa baseado no tipo
        if filename.lower().endswith('.txt'):
            credenciais, br_creds, stats = await processar_arquivo_texto(
                file_content, filename, event.chat_id
            )
        elif filename.lower().endswith('.zip'):
            credenciais, br_creds, stats = await processar_arquivo_zip(
                file_content, filename, event.chat_id
            )
        elif filename.lower().endswith('.rar'):
            credenciais, br_creds, stats = await processar_arquivo_rar(
                file_content, filename, event.chat_id
            )
        
        # Atualiza mensagem com resultado
        if stats['valid_lines'] > 0:
            result_text = f"""
‚úÖ **Processamento Conclu√≠do!**

üìÅ **Arquivo:** `{filename}`
üìä **Estat√≠sticas:**
‚Ä¢ üìù Total processado: {stats['total_lines']:,} linhas
‚Ä¢ ‚úÖ Credenciais v√°lidas: {stats['valid_lines']:,}
‚Ä¢ üáßüá∑ URLs brasileiras: {stats['brazilian_lines']:,}
‚Ä¢ üóëÔ∏è Spam removido: {stats['spam_removed']:,}
‚Ä¢ üìà Taxa v√°lida: {(stats['valid_lines']/max(1,stats['total_lines'])*100):.1f}%

üîÑ **Enviando arquivos filtrados...**
            """
            await processing_msg.edit(result_text)
            
            # Envia arquivo com todas as credenciais v√°lidas
            if credenciais:
                await enviar_resultado_como_arquivo(
                    event.chat_id, credenciais, "geral", stats
                )
            
            # Envia arquivo separado com URLs brasileiras
            if br_creds:
                await enviar_resultado_como_arquivo(
                    event.chat_id, br_creds, "brasileiras", stats
                )
            
            await bot.send_message(
                event.chat_id,
                "‚úÖ **Processamento finalizado!**\n\n"
                "üì§ Arquivos enviados com credenciais filtradas.\n"
                "üîÑ Envie mais arquivos para continuar processando!"
            )
        
        else:
            await processing_msg.edit(
                f"‚ùå **Nenhuma credencial v√°lida encontrada**\n\n"
                f"üìÅ **Arquivo:** `{filename}`\n"
                f"üìä **Motivos:**\n"
                f"‚Ä¢ {stats['spam_removed']:,} linhas de spam/divulga√ß√£o removidas\n"
                f"‚Ä¢ {stats['total_lines'] - stats['spam_removed']:,} linhas com formato inv√°lido\n\n"
                f"**Formato esperado:** `url:user:pass`"
            )
    
    except Exception as e:
        logger.error(f"Erro no processamento: {e}")
        await processing_msg.edit(
            f"‚ùå **Erro no processamento:**\n"
            f"`{str(e)[:100]}`\n\n"
            f"Tente novamente ou verifique o arquivo."
        )

@bot.on(events.NewMessage(pattern=r'/help'))
async def help_handler(event):
    """Handler do comando /help"""
    help_text = """
ü§ñ **Comandos dispon√≠veis:**

/start - Iniciar o bot
/adicionar - Ativar modo de adi√ß√£o de arquivos
/help - Mostrar esta ajuda
/stats - Estat√≠sticas de uso

üìÅ **Formatos suportados:**
‚Ä¢ TXT - Arquivos de texto puro
‚Ä¢ ZIP - Compactados ZIP com TXTs internos
‚Ä¢ RAR - Compactados RAR com TXTs internos

üõ°Ô∏è **Filtragem autom√°tica (igual ao painel):**
‚Ä¢ Remove divulga√ß√£o, spam, nomes, propaganda
‚Ä¢ Remove links promocionais e termos de hack
‚Ä¢ Mant√©m apenas formato URL:USER:PASS limpo
‚Ä¢ Detecta URLs brasileiras (.br + sites nacionais)

üáßüá∑ **Detec√ß√£o brasileira expandida:**
‚Ä¢ Sites .br autom√°ticos
‚Ä¢ Bancos (Ita√∫, Bradesco, BB, Santander, etc)
‚Ä¢ E-commerce (Mercado Livre, Americanas, etc)
‚Ä¢ Comunica√ß√£o (Vivo, Tim, Claro, UOL, etc)

‚ö° **Tecnologia:**
‚Ä¢ Telethon com API_ID/API_HASH/TOKEN
‚Ä¢ Processamento na nuvem do Telegram
‚Ä¢ Sem uso de RAM/mem√≥ria local
‚Ä¢ Arquivos at√© 2GB (limite Telegram)
    """
    
    await event.reply(help_text)

@bot.on(events.NewMessage(pattern=r'/ativarweb'))
async def ativar_web_handler(event):
    """Handler do comando /ativarweb - apenas admin"""
    user_id = str(event.sender_id)
    
    # Verifica se √© admin
    if user_id != str(ADMIN_ID):
        await event.reply("‚ùå **Acesso negado!** Apenas o admin pode usar este comando.")
        return
    
    global painel_ativo
    
    if painel_ativo:
        await event.reply("‚ö†Ô∏è **Painel web j√° est√° ativo!**")
        return
    
    try:
        # Ativa painel web
        import subprocess
        subprocess.Popen(["python", "app_web.py"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        painel_ativo = True
        
        await event.reply(
            "‚úÖ **Painel Web Ativado!**\n\n"
            "üåê **URL:** Confira na aba preview do Replit\n"
            "‚ö° **Status:** Online e funcionando\n"
            "üîß **Funcionalidades:** Todas do painel original\n\n"
            "Para desativar, use `/desativarweb`"
        )
        
    except Exception as e:
        await event.reply(f"‚ùå **Erro ao ativar painel:** `{str(e)[:50]}`")

@bot.on(events.NewMessage(pattern=r'/desativarweb'))
async def desativar_web_handler(event):
    """Handler do comando /desativarweb - apenas admin"""
    user_id = str(event.sender_id)
    
    # Verifica se √© admin
    if user_id != str(ADMIN_ID):
        await event.reply("‚ùå **Acesso negado!** Apenas o admin pode usar este comando.")
        return
    
    global painel_ativo
    painel_ativo = False
    
    await event.reply(
        "üî¥ **Painel Web Desativado!**\n\n"
        "‚ö†Ô∏è **Nota:** O processo pode continuar em background\n"
        "Para reativar, use `/ativarweb`"
    )

@bot.on(events.NewMessage(pattern=r'/status'))
async def status_handler(event):
    """Handler do comando /status"""
    user_id = str(event.sender_id)
    is_admin = (user_id == str(ADMIN_ID))
    
    status_text = f"""
üìä **Status do Sistema:**

ü§ñ **Bot:** Online e funcionando
üåê **Painel Web:** {"üü¢ Ativo" if painel_ativo else "üî¥ Inativo"}
‚ö° **Tecnologia:** Telethon + Flask
üóÑÔ∏è **Storage:** Nuvem Telegram (0% RAM)

üõ°Ô∏è **Filtros ativos:**
‚Ä¢ ‚úÖ Spam e divulga√ß√£o
‚Ä¢ ‚úÖ Nomes e apelidos  
‚Ä¢ ‚úÖ Links promocionais
‚Ä¢ ‚úÖ Termos de hack/crack

üáßüá∑ **Detec√ß√£o brasileira:**
‚Ä¢ ‚úÖ URLs .br autom√°ticas
‚Ä¢ ‚úÖ +50 sites nacionais
‚Ä¢ ‚úÖ Bancos, e-commerce, governo
    """
    
    if is_admin:
        status_text += f"""

üëë **Painel Admin:**
‚Ä¢ `/ativarweb` - Ativar painel web
‚Ä¢ `/desativarweb` - Desativar painel web
‚Ä¢ `/logs` - Ver logs do sistema
        """
    
    await event.reply(status_text)

@bot.on(events.NewMessage(pattern=r'/comandos'))
async def comandos_handler(event):
    """Handler do comando /comandos"""
    user_id = str(event.sender_id)
    is_admin = (user_id == str(ADMIN_ID))
    
    comandos_text = """
ü§ñ **Comandos Dispon√≠veis:**

üì§ **Processamento:**
‚Ä¢ `/start` - Iniciar o bot
‚Ä¢ `/adicionar` - Ativar modo de adi√ß√£o
‚Ä¢ `/help` - Ajuda detalhada

üìä **Informa√ß√µes:**
‚Ä¢ `/status` - Status do sistema
‚Ä¢ `/comandos` - Lista de comandos
‚Ä¢ `/sobre` - Sobre o projeto

üîß **Utilidades:**
‚Ä¢ Digite `/adicionar` e envie TXT/ZIP/RAR
‚Ä¢ Processamento autom√°tico com filtros
‚Ä¢ Resultado em arquivos organizados
    """
    
    if is_admin:
        comandos_text += """

üëë **Admin apenas:**
‚Ä¢ `/ativarweb` - Ativar painel web
‚Ä¢ `/desativarweb` - Desativar painel  
‚Ä¢ `/logs` - Ver logs do sistema
        """
    
    await event.reply(comandos_text)

@bot.on(events.NewMessage(pattern=r'/sobre'))
async def sobre_handler(event):
    """Handler do comando /sobre"""
    sobre_text = """
ü§ñ **Bot Processador Gigante 4GB**

üìã **Projeto:**
Sistema completo para processamento de credenciais com todas as funcionalidades do painel original em formato bot.

‚ö° **Tecnologia:**
‚Ä¢ **Bot:** Telethon (API_ID + API_HASH + TOKEN)
‚Ä¢ **Painel:** Flask (ativa√ß√£o sob demanda)
‚Ä¢ **Storage:** 100% nuvem do Telegram
‚Ä¢ **RAM:** 0% uso de mem√≥ria local

üõ°Ô∏è **Filtros implementados:**
‚Ä¢ Remove spam, divulga√ß√£o, propaganda
‚Ä¢ Remove nomes, apelidos, links promocionais
‚Ä¢ Detecta URLs brasileiras expandidas
‚Ä¢ Mant√©m apenas formato URL:USER:PASS

üáßüá∑ **Detec√ß√£o brasileira:**
‚Ä¢ Sites .br autom√°ticos
‚Ä¢ Bancos (Ita√∫, Bradesco, BB, Santander...)
‚Ä¢ E-commerce (ML, Americanas, Magazine...)
‚Ä¢ Telecom (Vivo, Tim, Claro, UOL...)

üìà **Capacidades:**
‚Ä¢ Arquivos at√© 2GB (limite Telegram)
‚Ä¢ Formatos: TXT, ZIP, RAR
‚Ä¢ Processamento streaming
‚Ä¢ Filtros igual ao painel original
    """
    
    await event.reply(sobre_text)

@bot.on(events.NewMessage(pattern=r'/logs'))
async def logs_handler(event):
    """Handler do comando /logs - apenas admin"""
    user_id = str(event.sender_id)
    
    # Verifica se √© admin
    if user_id != str(ADMIN_ID):
        await event.reply("‚ùå **Acesso negado!** Apenas o admin pode ver logs.")
        return
    
    try:
        # L√™ √∫ltimas linhas do log (se existir)
        logs_text = "üìã **Logs do Sistema:**\n\n"
        logs_text += f"ü§ñ **Bot Status:** Online\n"
        logs_text += f"üåê **Painel:** {'Ativo' if painel_ativo else 'Inativo'}\n"
        logs_text += f"‚è∞ **Timestamp:** {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\n\n"
        logs_text += f"üíæ **Mem√≥ria:** Usando apenas nuvem Telegram\n"
        logs_text += f"üîÑ **Processamento:** Streaming direto\n"
        
        await event.reply(logs_text)
        
    except Exception as e:
        await event.reply(f"‚ùå **Erro ao buscar logs:** `{str(e)[:50]}`")

@bot.on(events.NewMessage(pattern=r'/stats'))
async def stats_handler(event):
    """Handler do comando /stats"""
    stats_text = f"""
üìä **Estat√≠sticas do Bot:**

ü§ñ **Status:** Online e funcionando
üåê **Painel Web:** {"üü¢ Ativo" if painel_ativo else "üî¥ Inativo"}
‚ö° **Tecnologia:** Telethon + Nuvem Telegram
üóÑÔ∏è **Armazenamento:** Apenas nuvem (0% RAM local)

üõ°Ô∏è **Filtros ativos:**
‚Ä¢ Spam e divulga√ß√£o
‚Ä¢ Nomes e apelidos
‚Ä¢ Links promocionais
‚Ä¢ Termos de hack/crack

üáßüá∑ **Detec√ß√£o brasileira:**
‚Ä¢ URLs .br autom√°ticas
‚Ä¢ +50 sites nacionais .com/.net
‚Ä¢ Bancos, e-commerce, governo

üì§ **Uso:**
Digite `/adicionar` e envie seus arquivos!
    """
    
    await event.reply(stats_text)

# ========== FUN√á√ÉO PRINCIPAL ==========

async def main():
    """Fun√ß√£o principal do bot"""
    logger.info("ü§ñ Iniciando Bot Processador Gigante 4GB com Telethon...")
    
    # Conecta ao Telegram
    await bot.start(bot_token=BOT_TOKEN)
    logger.info("‚úÖ Bot conectado! Aguardando mensagens...")
    
    # Mant√©m o bot rodando
    await bot.run_until_disconnected()

if __name__ == "__main__":
    bot.loop.run_until_complete(main())