#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ü§ñ Bot do Telegram - Sistema Gigante 4GB com Telethon
Todas as funcionalidades do painel em vers√£o bot
Usando apenas a nuvem do Telegram - sem RAM/mem√≥ria local
"""

import os
import logging
import re
import io
import zipfile
import rarfile
import asyncio
import tempfile
from urllib.parse import urlparse
from datetime import datetime
from telethon import TelegramClient, events, Button
from telethon.tl.types import DocumentAttributeFilename
import time

# Configura√ß√µes de logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ========== CONFIGURA√á√ïES DO BOT TELETHON ==========
# Credenciais obtidas das vari√°veis de ambiente
API_ID = os.environ.get("API_ID")
API_HASH = os.environ.get("API_HASH") 
BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
ADMIN_ID = os.environ.get("ADMIN_ID", "123456789")  # ID do admin

if not API_ID or not API_HASH or not BOT_TOKEN:
    logger.error("‚ùå Configura√ß√µes faltando! Configure: API_ID, API_HASH, TELEGRAM_BOT_TOKEN")
    exit(1)

try:
    api_id_int = int(API_ID)
    admin_id_int = int(ADMIN_ID)
except (ValueError, TypeError):
    logger.error("‚ùå API_ID e ADMIN_ID devem ser n√∫meros!")
    exit(1)

# Cliente Telethon
bot = TelegramClient('bot', api_id_int, API_HASH)

# Controle do painel web
painel_ativo = False

# Controle de uploads em lote
upload_tasks = {}  # {chat_id: {'active': bool, 'files': [], 'results': []}}
processing_queue = {}  # {chat_id: asyncio.Queue}

# ========== FUN√á√ïES DE FILTRAGEM (do painel original) ==========

def detectar_url_brasileira(url):
    """
    Detecta URLs brasileiras (.br + sites nacionais conhecidos)
    IGUAL AO PAINEL ORIGINAL
    """
    url_lower = url.lower()
    
    # URLs .br diretas
    if '.br' in url_lower:
        return True
    
    # Sites brasileiros .com/.net conhecidos (LISTA EXPANDIDA DO PAINEL)
    sites_br_conhecidos = [
        # Bancos
        'itau.com', 'bradesco.com', 'bb.com', 'santander.com',
        'sicoob.com', 'sicredi.com', 'banrisul.com', 'caixa.gov',
        'bndes.gov', 'bcb.gov', 'nubank.com', 'inter.co',
        
        # E-commerce
        'mercadolivre.com', 'americanas.com', 'magazineluiza.com',
        'casasbahia.com', 'extra.com', 'pontofrio.com',
        'submarino.com', 'shoptime.com', 'netshoes.com',
        'dafiti.com', 'kanui.com', 'centauro.com',
        
        # Tecnologia e Comunica√ß√£o
        'uol.com', 'globo.com', 'terra.com', 'ig.com',
        'bol.com', 'zipmail.com', 'hotmail.com',
        'vivo.com', 'tim.com', 'claro.com', 'oi.com',
        
        # Governo e Servi√ßos
        'correios.com', 'anatel.gov', 'receita.fazenda.gov',
        'detran.', 'tjsp.jus', 'tjrj.jus', 'jus.com',
        'gov.br', 'inss.gov', 'caixa.gov', 'serpro.gov',
        
        # Outros populares
        'abril.com', 'folha.com', 'estadao.com', 'r7.com',
        'band.com', 'sbt.com', 'record.com', 'globoplay.com'
    ]
    
    return any(site in url_lower for site in sites_br_conhecidos)

def linha_valida(linha):
    """
    Valida se linha tem formato de credencial v√°lido
    IGUAL AO PAINEL ORIGINAL
    """
    if not linha or len(linha) < 5:
        return False
    
    # Conta dois pontos na linha
    count_dois_pontos = linha.count(':')
    if count_dois_pontos < 2:
        return False
    
    # Verifica se n√£o √© s√≥ caracteres especiais
    if re.match(r'^[^a-zA-Z0-9]*$', linha):
        return False
    
    return True

def filtrar_spam_divulgacao(linha):
    """
    Remove linhas de spam e divulga√ß√£o, deixando s√≥ URL:USER:PASS
    FILTROS IGUAIS AO PAINEL ORIGINAL
    """
    linha_lower = linha.lower()
    
    # Lista de termos de spam/divulga√ß√£o para remover (DO PAINEL)
    termos_spam = [
        # Divulga√ß√£o comum
        'telegram.me', 'telegram.org', 't.me', '@', 'canal', 'grupo',
        'divulga', 'vendas', 'contato', 'whatsapp', 'zap',
        
        # Nomes/apelidos
        'admin', 'moderador', 'vendedor', 'hacker', 'cracker',
        'owner', 'dono', 'chefe', 'boss', 'master',
        
        # Propaganda
        'comprar', 'vender', 'barato', 'promo', 'desconto',
        'gratis', 'free', 'premium', 'vip', 'exclusivo',
        
        # Links promocionais
        'bit.ly', 'tinyurl', 'encurtador', 'link',
        'acesse', 'clique', 'download', 'baixar',
        
        # Textos promocionais
        'melhor', 'top', 'qualidade', 'confiavel', 'seguro',
        'rapido', 'facil', 'simples', 'garantido',
        
        # Termos de hack
        'combo', 'list', 'lista', 'pack', 'pacote',
        'fresh', 'novo', 'updated', 'atualizado'
    ]
    
    # Se cont√©m termos de spam, remove a linha
    for termo in termos_spam:
        if termo in linha_lower:
            return None
    
    # Se n√£o √© formato URL:USER:PASS, remove
    if not linha_valida(linha):
        return None
    
    return linha.strip()

def processar_credencial(linha):
    """
    Processa uma linha de credencial e extrai dados
    IGUAL AO PAINEL ORIGINAL
    """
    linha_limpa = linha.strip()
    
    # Filtra spam primeiro
    linha_filtrada = filtrar_spam_divulgacao(linha_limpa)
    if not linha_filtrada:
        return None
    
    try:
        # Separa por dois pontos
        partes = linha_filtrada.split(':')
        
        # Formato: http://site.com:user:pass
        if linha_filtrada.startswith(('https://', 'http://')):
            if len(partes) >= 3:
                url = ':'.join(partes[:-2])
                username = partes[-2]
                password = partes[-1]
            else:
                return None
        # Formato: site.com:user:pass
        else:
            if len(partes) >= 3:
                url = partes[0]
                username = partes[1]
                password = partes[2]
            else:
                return None
        
        # Valida√ß√µes b√°sicas
        if not all([url, username, password]):
            return None
        
        if len(username) < 2 or len(password) < 2:
            return None
        
        # Retorna dados estruturados
        return {
            'url': url.strip(),
            'username': username.strip(),
            'password': password.strip(),
            'linha_completa': linha_filtrada,
            'is_brazilian': detectar_url_brasileira(url)
        }
    
    except Exception:
        return None

# ========== PROCESSAMENTO DE ARQUIVOS ==========

async def processar_arquivo_texto(content, filename, chat_id):
    """
    Processa arquivo de texto com filtragem completa
    USANDO APENAS NUVEM DO TELEGRAM - SEM RAM LOCAL
    """
    try:
        # Decodifica content
        if isinstance(content, bytes):
            text_content = content.decode('utf-8', errors='ignore')
        else:
            text_content = content
        
        lines = text_content.split('\n')
        
        credenciais_validas = []
        credenciais_br = []
        stats = {
            'total_lines': len(lines),
            'valid_lines': 0,
            'brazilian_lines': 0,
            'spam_removed': 0
        }
        
        # Processa cada linha
        for linha in lines:
            if not linha.strip():
                continue
            
            # Processa credencial
            credencial = processar_credencial(linha)
            
            if credencial:
                credenciais_validas.append(credencial['linha_completa'])
                stats['valid_lines'] += 1
                
                # Se √© brasileira, adiciona √† lista BR
                if credencial['is_brazilian']:
                    credenciais_br.append(credencial['linha_completa'])
                    stats['brazilian_lines'] += 1
            else:
                stats['spam_removed'] += 1
        
        return credenciais_validas, credenciais_br, stats
    
    except Exception as e:
        logger.error(f"Erro no processamento: {e}")
        return [], [], {'total_lines': 0, 'valid_lines': 0, 'brazilian_lines': 0, 'spam_removed': 0}

async def processar_arquivo_zip(content, filename, chat_id):
    """
    Processa arquivo ZIP com m√∫ltiplos TXTs
    """
    try:
        with zipfile.ZipFile(io.BytesIO(content), 'r') as zip_file:
            todas_credenciais = []
            todas_br = []
            stats_total = {'total_lines': 0, 'valid_lines': 0, 'brazilian_lines': 0, 'spam_removed': 0}
            
            for file_info in zip_file.filelist:
                if file_info.filename.lower().endswith('.txt'):
                    with zip_file.open(file_info) as txt_file:
                        txt_content = txt_file.read()
                        
                        credenciais, br_creds, stats = await processar_arquivo_texto(
                            txt_content, f"{filename}:{file_info.filename}", chat_id
                        )
                        
                        todas_credenciais.extend(credenciais)
                        todas_br.extend(br_creds)
                        
                        # Soma estat√≠sticas
                        for key in stats_total:
                            stats_total[key] += stats[key]
            
            return todas_credenciais, todas_br, stats_total
    
    except Exception as e:
        logger.error(f"Erro no ZIP: {e}")
        return [], [], {'total_lines': 0, 'valid_lines': 0, 'brazilian_lines': 0, 'spam_removed': 0}

async def processar_arquivo_rar(content, filename, chat_id):
    """
    Processa arquivo RAR com m√∫ltiplos TXTs
    """
    try:
        # Salva temporariamente (necess√°rio para rarfile)
        temp_path = os.path.join(tempfile.gettempdir(), f"temp_{int(time.time())}.rar")
        with open(temp_path, 'wb') as f:
            f.write(content)
        
        todas_credenciais = []
        todas_br = []
        stats_total = {'total_lines': 0, 'valid_lines': 0, 'brazilian_lines': 0, 'spam_removed': 0}
        
        with rarfile.RarFile(temp_path, 'r') as rar_file:
            for file_info in rar_file.namelist():
                if file_info.lower().endswith('.txt'):
                    with rar_file.open(file_info) as txt_file:
                        txt_content = txt_file.read()
                        
                        credenciais, br_creds, stats = await processar_arquivo_texto(
                            txt_content, f"{filename}:{file_info}", chat_id
                        )
                        
                        todas_credenciais.extend(credenciais)
                        todas_br.extend(br_creds)
                        
                        # Soma estat√≠sticas
                        for key in stats_total:
                            stats_total[key] += stats[key]
        
        # Remove arquivo tempor√°rio
        temp_path = locals().get('temp_path')
        if temp_path and os.path.exists(temp_path):
            os.remove(temp_path)
        
        return todas_credenciais, todas_br, stats_total
    
    except Exception as e:
        logger.error(f"Erro no RAR: {e}")
        # Remove arquivo tempor√°rio se existir
        try:
            temp_path_local = locals().get('temp_path')
            if temp_path_local and os.path.exists(temp_path_local):
                os.remove(temp_path_local)
        except:
            pass
        return [], [], {'total_lines': 0, 'valid_lines': 0, 'brazilian_lines': 0, 'spam_removed': 0}

# ========== FUN√á√ïES DE ENVIO DE RESULTADOS ==========

async def enviar_resultado_como_arquivo(chat_id, credenciais, tipo, stats):
    """
    Envia resultado como arquivo na nuvem do Telegram
    """
    if not credenciais:
        await bot.send_message(chat_id, f"‚ùå Nenhuma credencial {tipo} encontrada.")
        return
    
    try:
        # Cria conte√∫do do arquivo
        content = '\n'.join(credenciais)
        
        # Nome do arquivo com timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"credenciais_{tipo}_{timestamp}.txt"
        
        logger.info(f"Enviando arquivo: {filename} com {len(credenciais)} credenciais")
        
        # Envia como arquivo
        await bot.send_file(
            chat_id,
            io.BytesIO(content.encode('utf-8')),
            attributes=[DocumentAttributeFilename(filename)],
            caption=f"üìÅ **{filename}**\n\n"
                   f"‚úÖ {len(credenciais):,} credenciais {tipo}\n"
                   f"üìä Taxa: {(stats['valid_lines']/max(1,stats['total_lines'])*100):.1f}%"
        )
        
        logger.info(f"Arquivo enviado com sucesso: {filename}")
        
    except Exception as e:
        logger.error(f"Erro ao enviar arquivo {tipo}: {e}")
        await bot.send_message(chat_id, f"‚ùå Erro ao enviar arquivo {tipo}: {str(e)[:100]}")

# ========== HANDLERS DO BOT ==========

@bot.on(events.NewMessage(pattern=r'^/start$'))
async def start_handler(event):
    """Handler do comando /start"""
    logger.info(f"Comando /start recebido de {event.sender_id}")
    user = await event.get_sender()
    welcome_text = f"""ü§ñ **Bot Processador Gigante 4GB - Telethon**

Ol√° {user.first_name}! üëã

üöÄ **Todas as fun√ß√µes do painel em bot:**
‚Ä¢ Processamento de arquivos TXT, ZIP e RAR at√© 4GB
‚Ä¢ Filtragem autom√°tica de spam e divulga√ß√£o  
‚Ä¢ Detec√ß√£o de URLs brasileiras expandida
‚Ä¢ Uso apenas da nuvem do Telegram (sem RAM local)

üì§ **Como usar:**
1. Digite `/adicionar` para iniciar
2. Encaminhe seus arquivos TXT/ZIP/RAR
3. Receba os resultados filtrados automaticamente

üáßüá∑ **Filtros implementados:**
‚Ä¢ Remove spam, divulga√ß√£o, nomes, propaganda
‚Ä¢ Detecta sites brasileiros (.br + nacionais .com/.net)
‚Ä¢ Mant√©m apenas formato URL:USER:PASS limpo
‚Ä¢ Filtragem igual ao painel original

Digite `/adicionar` para come√ßar!"""
    
    await event.reply(welcome_text)

@bot.on(events.NewMessage(pattern=r'^/adicionar$'))
async def adicionar_handler(event):
    """Handler do comando /adicionar"""
    chat_id = event.chat_id
    user_id = event.sender_id
    
    logger.info(f"Comando /adicionar recebido de {user_id} no chat {chat_id}")
    
    # Inicializa controle de upload para este chat
    upload_tasks[chat_id] = {
        'active': True,
        'files': [],
        'results': {'credenciais': [], 'brasileiras': []},
        'stats': {'total_lines': 0, 'valid_lines': 0, 'brazilian_lines': 0, 'spam_removed': 0},
        'files_count': 0,
        'processed_count': 0
    }
    
    # Cria fila de processamento
    processing_queue[chat_id] = asyncio.Queue()
    
    await event.reply(
        "üì§ **Modo Processamento em Lote Ativado!**\n\n"
        "üöÄ **Novo sistema:**\n"
        "‚Ä¢ Envie **v√°rios arquivos de uma vez**\n"
        "‚Ä¢ Download e processamento **um por vez**\n"
        "‚Ä¢ **Progresso detalhado** de cada arquivo\n"
        "‚Ä¢ **Resultado final unificado** no fim\n\n"
        "üìÅ **Formatos suportados:**\n"
        "‚Ä¢ üìÑ TXT - Arquivos de texto\n"
        "‚Ä¢ üì¶ ZIP - Compactados ZIP\n" 
        "‚Ä¢ üì¶ RAR - Compactados RAR\n\n"
        "‚ö° **Funcionalidades:**\n"
        "‚Ä¢ Filtragem de spam/divulga√ß√£o\n"
        "‚Ä¢ Detec√ß√£o de URLs brasileiras\n"
        "‚Ä¢ Processamento na nuvem do Telegram\n\n"
        "üîÑ **Envie seus arquivos!** (ou `/cancelarupload` para cancelar)"
    )
    
    # Inicia processador em background
    asyncio.create_task(processar_fila_uploads(chat_id))

@bot.on(events.NewMessage)
async def progress_callback(current, total, progress_msg, filename, start_time):
    """Callback para mostrar progresso do download"""
    try:
        # Calcula estat√≠sticas
        percent = (current / total) * 100
        elapsed = time.time() - start_time
        
        if elapsed > 0 and current > 0:
            speed = current / elapsed  # bytes por segundo
            speed_mb = speed / (1024 * 1024)  # MB/s
            
            # Estima tempo restante
            remaining_bytes = total - current
            if speed > 0:
                eta_seconds = remaining_bytes / speed
                eta_minutes = eta_seconds / 60
                
                if eta_minutes < 1:
                    eta_str = f"{eta_seconds:.0f}s"
                elif eta_minutes < 60:
                    eta_str = f"{eta_minutes:.1f}min"
                else:
                    eta_hours = eta_minutes / 60
                    eta_str = f"{eta_hours:.1f}h"
            else:
                eta_str = "calculando..."
        else:
            speed_mb = 0
            eta_str = "calculando..."
        
        # Barra de progresso visual
        filled = int(percent / 5)  # 20 blocos = 100%
        bar = "‚ñà" * filled + "‚ñë" * (20 - filled)
        
        # Atualiza mensagem a cada 5% ou a cada 3 segundos
        if percent % 5 < 1 or elapsed % 3 < 1:
            progress_text = f"""
üì• **Download em Progresso**

üìÅ **Arquivo:** `{filename}`
üìä **Progresso:** {percent:.1f}%
{bar}

üìà **Estat√≠sticas:**
‚Ä¢ ‚¨áÔ∏è **Baixado:** {current / (1024*1024):.1f} MB / {total / (1024*1024):.1f} MB
‚Ä¢ üöÄ **Velocidade:** {speed_mb:.1f} MB/s
‚Ä¢ ‚è±Ô∏è **Tempo restante:** {eta_str}
‚Ä¢ ‚è∞ **Decorrido:** {elapsed:.0f}s

‚ö° **Aguarde...** Ap√≥s o download, iniciar√° o processamento!
            """
            
            await progress_msg.edit(progress_text)
    
    except Exception as e:
        # Se der erro no progresso, n√£o interrompe o download
        logger.error(f"Erro no callback de progresso: {e}")

@bot.on(events.NewMessage(pattern=r'^/adicionar$'))
async def adicionar_handler(event):
    """Handler do comando /adicionar"""
    chat_id = event.chat_id
    user_id = event.sender_id
    
    logger.info(f"Comando /adicionar recebido de {user_id} no chat {chat_id}")
    
    # Inicializa controle de upload para este chat
    upload_tasks[chat_id] = {
        'active': True,
        'files': [],
        'results': {'credenciais': [], 'brasileiras': []},
        'stats': {'total_lines': 0, 'valid_lines': 0, 'brazilian_lines': 0, 'spam_removed': 0},
        'files_count': 0,
        'processed_count': 0
    }
    
    # Cria fila de processamento
    processing_queue[chat_id] = asyncio.Queue()
    
    await event.reply(
        "üì§ **Modo Processamento em Lote Ativado!**\n\n"
        "üöÄ **Novo sistema:**\n"
        "‚Ä¢ Envie **v√°rios arquivos de uma vez**\n"
        "‚Ä¢ Download e processamento **um por vez**\n"
        "‚Ä¢ **Progresso detalhado** de cada arquivo\n"
        "‚Ä¢ **Resultado final unificado** no fim\n\n"
        "üìÅ **Formatos suportados:**\n"
        "‚Ä¢ üìÑ TXT - Arquivos de texto\n"
        "‚Ä¢ üì¶ ZIP - Compactados ZIP\n" 
        "‚Ä¢ üì¶ RAR - Compactados RAR\n\n"
        "‚ö° **Funcionalidades:**\n"
        "‚Ä¢ Filtragem de spam/divulga√ß√£o\n"
        "‚Ä¢ Detec√ß√£o de URLs brasileiras\n"
        "‚Ä¢ Processamento na nuvem do Telegram\n\n"
        "üîÑ **Envie seus arquivos!** (ou `/cancelarupload` para cancelar)"
    )
    
    # Inicia processador em background
    asyncio.create_task(processar_fila_uploads(chat_id))

async def processar_fila_uploads(chat_id):
    """Processa fila de uploads um por vez"""
    logger.info(f"Iniciando processador de fila para chat {chat_id}")
    
    try:
        while chat_id in upload_tasks and upload_tasks[chat_id]['active']:
            try:
                # Aguarda novo arquivo na fila (timeout 5 segundos)
                file_info = await asyncio.wait_for(
                    processing_queue[chat_id].get(), 
                    timeout=5.0
                )
                
                # Verifica se upload ainda ativo
                if not upload_tasks[chat_id]['active']:
                    logger.info(f"Upload cancelado para chat {chat_id}")
                    break
                
                await processar_arquivo_individual(chat_id, file_info)
                
            except asyncio.TimeoutError:
                # Timeout normal - continue aguardando
                continue
            except Exception as e:
                logger.error(f"Erro no processador de fila {chat_id}: {e}")
                break
        
        # Verifica se tem arquivos para finalizar
        if chat_id in upload_tasks and upload_tasks[chat_id]['processed_count'] > 0:
            await finalizar_processamento_lote(chat_id)
    
    except Exception as e:
        logger.error(f"Erro cr√≠tico no processador {chat_id}: {e}")
        if chat_id in upload_tasks:
            await bot.send_message(
                chat_id,
                f"‚ùå **Erro cr√≠tico no processamento:** `{str(e)[:100]}`\n"
                f"Digite `/adicionar` para recome√ßar"
            )

async def processar_arquivo_individual(chat_id, file_info):
    """Processa um arquivo individual"""
    try:
        event, filename, file_size = file_info
        
        # Atualiza contador
        upload_tasks[chat_id]['files_count'] += 1
        current_file = upload_tasks[chat_id]['files_count']
        
        # Mensagem de progresso
        progress_msg = await bot.send_message(
            chat_id,
            f"üì• **Download {current_file}¬∫ Arquivo**\n\n"
            f"üìÅ **Nome:** `{filename}`\n"
            f"üìè **Tamanho:** {file_size / 1024 / 1024:.1f} MB\n"
            f"‚ö° **Iniciando download com progresso...**"
        )
        
        # Download com callback de progresso
        start_time = time.time()
        
        async def file_progress(current, total):
            await progress_callback(current, total, progress_msg, filename, start_time)
        
        file_content = await event.download_media(
            bytes, 
            progress_callback=file_progress
        )
        
        if not file_content:
            await progress_msg.edit("‚ùå **Erro:** N√£o foi poss√≠vel baixar o arquivo")
            return
        
        download_time = time.time() - start_time
        
        # Atualiza para processamento
        await progress_msg.edit(
            f"üîÑ **Processando Arquivo {current_file}**\n\n"
            f"üìÅ **Nome:** `{filename}`\n"
            f"üìè **Tamanho:** {len(file_content) / 1024 / 1024:.1f} MB\n"
            f"‚è±Ô∏è **Download:** {download_time:.1f}s\n\n"
            f"‚ö° **Filtrando spam e URLs brasileiras...**"
        )
        
        # Processa arquivo
        processing_start = time.time()
        
        if filename.lower().endswith('.txt'):
            credenciais, br_creds, stats = await processar_arquivo_texto(
                file_content, filename, chat_id
            )
        elif filename.lower().endswith('.zip'):
            credenciais, br_creds, stats = await processar_arquivo_zip(
                file_content, filename, chat_id
            )
        elif filename.lower().endswith('.rar'):
            credenciais, br_creds, stats = await processar_arquivo_rar(
                file_content, filename, chat_id
            )
        
        processing_time = time.time() - processing_start
        
        # Adiciona aos resultados consolidados
        upload_tasks[chat_id]['results']['credenciais'].extend(credenciais)
        upload_tasks[chat_id]['results']['brasileiras'].extend(br_creds)
        
        # Soma estat√≠sticas
        for key in upload_tasks[chat_id]['stats']:
            upload_tasks[chat_id]['stats'][key] += stats[key]
        
        upload_tasks[chat_id]['processed_count'] += 1
        
        total_time = time.time() - start_time
        
        # Resultado do arquivo individual
        await progress_msg.edit(
            f"‚úÖ **Arquivo {current_file} Processado!**\n\n"
            f"üìÅ **Nome:** `{filename}`\n"
            f"üìè **Tamanho:** {len(file_content) / 1024 / 1024:.1f} MB\n"
            f"‚è±Ô∏è **Tempo total:** {total_time:.1f}s\n\n"
            f"üìä **Resultado deste arquivo:**\n"
            f"‚Ä¢ ‚úÖ V√°lidas: {stats['valid_lines']:,}\n"
            f"‚Ä¢ üáßüá∑ Brasileiras: {stats['brazilian_lines']:,}\n"
            f"‚Ä¢ üóëÔ∏è Spam: {stats['spam_removed']:,}\n\n"
            f"üìà **Acumulado total:**\n"
            f"‚Ä¢ ‚úÖ {len(upload_tasks[chat_id]['results']['credenciais']):,} credenciais\n"
            f"‚Ä¢ üáßüá∑ {len(upload_tasks[chat_id]['results']['brasileiras']):,} brasileiras\n\n"
            f"‚ö° **Aguardando pr√≥ximo arquivo ou finalizando...**"
        )
        
        logger.info(f"Arquivo {current_file} processado: {filename} - {stats['valid_lines']} v√°lidas")
        
    except Exception as e:
        logger.error(f"Erro no processamento individual: {e}")
        await bot.send_message(
            chat_id,
            f"‚ùå **Erro no arquivo:** `{filename}`\n"
            f"**Erro:** {str(e)[:100]}\n"
            f"‚ö° Continuando com pr√≥ximos arquivos..."
        )

async def finalizar_processamento_lote(chat_id):
    """Finaliza processamento e envia resultados consolidados"""
    try:
        if chat_id not in upload_tasks:
            return
        
        task_data = upload_tasks[chat_id]
        total_credenciais = task_data['results']['credenciais']
        total_brasileiras = task_data['results']['brasileiras']
        stats_finais = task_data['stats']
        files_processed = task_data['processed_count']
        
        # Mensagem de finaliza√ß√£o
        await bot.send_message(
            chat_id,
            f"üéØ **Processamento em Lote Finalizado!**\n\n"
            f"üìä **Resumo Final:**\n"
            f"‚Ä¢ üìÅ Arquivos processados: **{files_processed}**\n"
            f"‚Ä¢ üìù Linhas totais: **{stats_finais['total_lines']:,}**\n"
            f"‚Ä¢ ‚úÖ Credenciais v√°lidas: **{len(total_credenciais):,}**\n"
            f"‚Ä¢ üáßüá∑ URLs brasileiras: **{len(total_brasileiras):,}**\n"
            f"‚Ä¢ üóëÔ∏è Spam removido: **{stats_finais['spam_removed']:,}**\n\n"
            f"üìà **Taxa de aproveitamento:** {(len(total_credenciais)/max(1,stats_finais['total_lines'])*100):.1f}%\n\n"
            f"üì§ **Enviando resultados consolidados...**"
        )
        
        # Envia arquivo consolidado geral
        if total_credenciais:
            await enviar_resultado_como_arquivo(
                chat_id, total_credenciais, "LOTE_GERAL", stats_finais
            )
        
        # Envia arquivo consolidado brasileiro
        if total_brasileiras:
            await enviar_resultado_como_arquivo(
                chat_id, total_brasileiras, "LOTE_BRASILEIRAS", stats_finais
            )
        
        # Mensagem de conclus√£o
        await bot.send_message(
            chat_id,
            f"üéâ **Processamento Completo!**\n\n"
            f"‚úÖ **Todos os {files_processed} arquivos processados**\n"
            f"üì§ **Resultados consolidados enviados**\n"
            f"üèÅ **Sistema pronto para novos uploads**\n\n"
            f"üîÑ **Para novo lote:** `/adicionar`\n"
            f"‚ùå **Para cancelar:** `/cancelarupload`"
        )
        
        # Limpa dados da sess√£o
        if chat_id in upload_tasks:
            del upload_tasks[chat_id]
        if chat_id in processing_queue:
            del processing_queue[chat_id]
        
        logger.info(f"Processamento em lote finalizado para chat {chat_id}: {len(total_credenciais)} credenciais")
        
    except Exception as e:
        logger.error(f"Erro na finaliza√ß√£o do lote {chat_id}: {e}")
        await bot.send_message(
            chat_id,
            f"‚ùå **Erro na finaliza√ß√£o:** `{str(e)[:100]}`\n"
            f"Digite `/adicionar` para recome√ßar"
        )

@bot.on(events.NewMessage)
async def document_handler(event):
    """Handler para documentos enviados - sistema de fila"""
    # S√≥ processa documentos
    if not event.document:
        return
    
    chat_id = event.chat_id
    
    # Verifica se modo adi√ß√£o est√° ativo
    if chat_id not in upload_tasks or not upload_tasks[chat_id]['active']:
        return  # Ignora se modo n√£o ativo
    
    # Extrai filename
    filename = None
    for attr in event.document.attributes:
        if hasattr(attr, 'file_name'):
            filename = attr.file_name
            break
    
    if not filename:
        filename = f"arquivo_{int(time.time())}.txt"
    
    # Verifica formato
    if not filename.lower().endswith(('.txt', '.zip', '.rar')):
        await event.reply(
            "‚ùå **Formato n√£o suportado!**\n"
            "Use apenas: TXT, ZIP, RAR\n"
            "üì§ Continue enviando outros arquivos v√°lidos"
        )
        return
    
    # Verifica tamanho
    file_size = event.document.size
    if file_size > 2 * 1024 * 1024 * 1024:  # 2GB
        await event.reply(
            "‚ùå **Arquivo muito grande!**\n"
            f"üìè **Tamanho:** {file_size / 1024 / 1024:.1f} MB\n"
            f"üìê **Limite:** 2GB\n"
            "Divida em partes menores e continue enviando"
        )
        return
    
    # Adiciona √† fila
    file_info = (event, filename, file_size)
    await processing_queue[chat_id].put(file_info)
    
    # Confirma adi√ß√£o √† fila
    queue_size = processing_queue[chat_id].qsize()
    await event.reply(
        f"üìã **Arquivo Adicionado √† Fila!**\n\n"
        f"üìÅ **Nome:** `{filename}`\n"
        f"üìè **Tamanho:** {file_size / 1024 / 1024:.1f} MB\n"
        f"üî¢ **Posi√ß√£o na fila:** {queue_size}\n\n"
        f"‚ö° **Status:** Ser√° processado automaticamente\n"
        f"üîÑ **Continue enviando** mais arquivos ou aguarde\n"
        f"‚ùå **Para cancelar:** `/cancelarupload`"
    )
    
    logger.info(f"Arquivo {filename} adicionado √† fila do chat {chat_id}, posi√ß√£o {queue_size}")

@bot.on(events.NewMessage(pattern=r'^/teste$'))
async def teste_handler(event):
    """Handler do comando /teste - para testar funcionamento"""
    await event.reply(
        "‚úÖ **Bot funcionando perfeitamente!**\n\n"
        "üîß **Teste de funcionalidades:**\n"
        "‚Ä¢ Recebimento de mensagens: ‚úÖ\n"
        "‚Ä¢ Envio de respostas: ‚úÖ\n"
        "‚Ä¢ Processamento de comandos: ‚úÖ\n\n"
        "üì§ **Para testar upload:**\n"
        "1. Digite `/adicionar`\n"
        "2. Envie um arquivo TXT pequeno\n"
        "3. Aguarde o processamento\n\n"
        "Se ainda tiver problemas, use `/help`"
    )

@bot.on(events.NewMessage(pattern=r'^/help$'))
async def help_handler(event):
    """Handler do comando /help"""
    help_text = """
ü§ñ **Comandos dispon√≠veis:**

/start - Iniciar o bot
/adicionar - Ativar modo de processamento em lote
/cancelarupload - Cancelar uploads em andamento
/help - Mostrar esta ajuda
/stats - Estat√≠sticas de uso

üìÅ **Formatos suportados:**
‚Ä¢ TXT - Arquivos de texto puro
‚Ä¢ ZIP - Compactados ZIP com TXTs internos
‚Ä¢ RAR - Compactados RAR com TXTs internos

üöÄ **Novo sistema de lote:**
‚Ä¢ Envie v√°rios arquivos de uma vez
‚Ä¢ Download e processamento um por vez com progresso
‚Ä¢ Resultado final consolidado √∫nico
‚Ä¢ Cancelamento a qualquer momento

üõ°Ô∏è **Filtragem autom√°tica (igual ao painel):**
‚Ä¢ Remove divulga√ß√£o, spam, nomes, propaganda
‚Ä¢ Remove links promocionais e termos de hack
‚Ä¢ Mant√©m apenas formato URL:USER:PASS limpo
‚Ä¢ Detecta URLs brasileiras (.br + sites nacionais)

üáßüá∑ **Detec√ß√£o brasileira expandida:**
‚Ä¢ Sites .br autom√°ticos
‚Ä¢ Bancos (Ita√∫, Bradesco, BB, Santander, etc)
‚Ä¢ E-commerce (Mercado Livre, Americanas, etc)
‚Ä¢ Comunica√ß√£o (Vivo, Tim, Claro, UOL, etc)

‚ö° **Tecnologia:**
‚Ä¢ Telethon com API_ID/API_HASH/TOKEN
‚Ä¢ Processamento na nuvem do Telegram
‚Ä¢ Sem uso de RAM/mem√≥ria local
‚Ä¢ Arquivos at√© 2GB (limite Telegram)
    """
    
    await event.reply(help_text)

@bot.on(events.NewMessage(pattern=r'^/ativarweb$'))
async def ativar_web_handler(event):
    """Handler do comando /ativarweb - apenas admin"""
    user_id = event.sender_id
    
    # Verifica se √© admin
    if user_id != admin_id_int:
        await event.reply("‚ùå **Acesso negado!** Apenas o admin pode usar este comando.")
        return
    
    global painel_ativo
    
    if painel_ativo:
        await event.reply("‚ö†Ô∏è **Painel web j√° est√° ativo!**")
        return
    
    try:
        # Ativa painel web
        import subprocess
        subprocess.Popen(["python", "app_web.py"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        painel_ativo = True
        
        await event.reply(
            "‚úÖ **Painel Web Ativado!**\n\n"
            "üåê **URL:** Confira na aba preview do Replit\n"
            "‚ö° **Status:** Online e funcionando\n"
            "üîß **Funcionalidades:** Todas do painel original\n\n"
            "Para desativar, use `/desativarweb`"
        )
        
    except Exception as e:
        await event.reply(f"‚ùå **Erro ao ativar painel:** `{str(e)[:50]}`")

@bot.on(events.NewMessage(pattern=r'^/desativarweb$'))
async def desativar_web_handler(event):
    """Handler do comando /desativarweb - apenas admin"""
    user_id = event.sender_id
    
    # Verifica se √© admin
    if user_id != admin_id_int:
        await event.reply("‚ùå **Acesso negado!** Apenas o admin pode usar este comando.")
        return
    
    global painel_ativo
    painel_ativo = False
    
    await event.reply(
        "üî¥ **Painel Web Desativado!**\n\n"
        "‚ö†Ô∏è **Nota:** O processo pode continuar em background\n"
        "Para reativar, use `/ativarweb`"
    )

@bot.on(events.NewMessage(pattern=r'^/status$'))
async def status_handler(event):
    """Handler do comando /status"""
    user_id = event.sender_id
    is_admin = (user_id == admin_id_int)
    
    status_text = f"""
üìä **Status do Sistema:**

ü§ñ **Bot:** Online e funcionando
üåê **Painel Web:** {"üü¢ Ativo" if painel_ativo else "üî¥ Inativo"}
‚ö° **Tecnologia:** Telethon + Flask
üóÑÔ∏è **Storage:** Nuvem Telegram (0% RAM)

üõ°Ô∏è **Filtros ativos:**
‚Ä¢ ‚úÖ Spam e divulga√ß√£o
‚Ä¢ ‚úÖ Nomes e apelidos  
‚Ä¢ ‚úÖ Links promocionais
‚Ä¢ ‚úÖ Termos de hack/crack

üáßüá∑ **Detec√ß√£o brasileira:**
‚Ä¢ ‚úÖ URLs .br autom√°ticas
‚Ä¢ ‚úÖ +50 sites nacionais
‚Ä¢ ‚úÖ Bancos, e-commerce, governo
    """
    
    if is_admin:
        status_text += f"""

üëë **Painel Admin:**
‚Ä¢ `/ativarweb` - Ativar painel web
‚Ä¢ `/desativarweb` - Desativar painel web
‚Ä¢ `/logs` - Ver logs do sistema
        """
    
    await event.reply(status_text)

@bot.on(events.NewMessage(pattern=r'^/comandos$'))
async def comandos_handler(event):
    """Handler do comando /comandos"""
    user_id = event.sender_id
    is_admin = (user_id == admin_id_int)
    
    comandos_text = """
ü§ñ **Comandos Dispon√≠veis:**

üì§ **Processamento:**
‚Ä¢ `/start` - Iniciar o bot
‚Ä¢ `/adicionar` - Ativar modo de adi√ß√£o
‚Ä¢ `/help` - Ajuda detalhada

üìä **Informa√ß√µes:**
‚Ä¢ `/status` - Status do sistema
‚Ä¢ `/comandos` - Lista de comandos
‚Ä¢ `/sobre` - Sobre o projeto

üîß **Utilidades:**
‚Ä¢ Digite `/adicionar` e envie TXT/ZIP/RAR
‚Ä¢ Processamento autom√°tico com filtros
‚Ä¢ Resultado em arquivos organizados
    """
    
    if is_admin:
        comandos_text += """

üëë **Admin apenas:**
‚Ä¢ `/ativarweb` - Ativar painel web
‚Ä¢ `/desativarweb` - Desativar painel  
‚Ä¢ `/logs` - Ver logs do sistema
        """
    
    await event.reply(comandos_text)

@bot.on(events.NewMessage(pattern=r'^/sobre$'))
async def sobre_handler(event):
    """Handler do comando /sobre"""
    sobre_text = """
ü§ñ **Bot Processador Gigante 4GB**

üìã **Projeto:**
Sistema completo para processamento de credenciais com todas as funcionalidades do painel original em formato bot.

‚ö° **Tecnologia:**
‚Ä¢ **Bot:** Telethon (API_ID + API_HASH + TOKEN)
‚Ä¢ **Painel:** Flask (ativa√ß√£o sob demanda)
‚Ä¢ **Storage:** 100% nuvem do Telegram
‚Ä¢ **RAM:** 0% uso de mem√≥ria local

üõ°Ô∏è **Filtros implementados:**
‚Ä¢ Remove spam, divulga√ß√£o, propaganda
‚Ä¢ Remove nomes, apelidos, links promocionais
‚Ä¢ Detecta URLs brasileiras expandidas
‚Ä¢ Mant√©m apenas formato URL:USER:PASS

üáßüá∑ **Detec√ß√£o brasileira:**
‚Ä¢ Sites .br autom√°ticos
‚Ä¢ Bancos (Ita√∫, Bradesco, BB, Santander...)
‚Ä¢ E-commerce (ML, Americanas, Magazine...)
‚Ä¢ Telecom (Vivo, Tim, Claro, UOL...)

üìà **Capacidades:**
‚Ä¢ Arquivos at√© 2GB (limite Telegram)
‚Ä¢ Formatos: TXT, ZIP, RAR
‚Ä¢ Processamento streaming
‚Ä¢ Filtros igual ao painel original
    """
    
    await event.reply(sobre_text)

@bot.on(events.NewMessage(pattern=r'^/logs$'))
async def logs_handler(event):
    """Handler do comando /logs - apenas admin"""
    user_id = event.sender_id
    
    # Verifica se √© admin
    if user_id != admin_id_int:
        await event.reply("‚ùå **Acesso negado!** Apenas o admin pode ver logs.")
        return
    
    try:
        # L√™ √∫ltimas linhas do log (se existir)
        logs_text = "üìã **Logs do Sistema:**\n\n"
        logs_text += f"ü§ñ **Bot Status:** Online\n"
        logs_text += f"üåê **Painel:** {'Ativo' if painel_ativo else 'Inativo'}\n"
        logs_text += f"‚è∞ **Timestamp:** {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\n\n"
        logs_text += f"üíæ **Mem√≥ria:** Usando apenas nuvem Telegram\n"
        logs_text += f"üîÑ **Processamento:** Streaming direto\n"
        
        await event.reply(logs_text)
        
    except Exception as e:
        await event.reply(f"‚ùå **Erro ao buscar logs:** `{str(e)[:50]}`")

@bot.on(events.NewMessage(pattern=r'^/stats$'))
async def stats_handler(event):
    """Handler do comando /stats"""
    stats_text = f"""
üìä **Estat√≠sticas do Bot:**

ü§ñ **Status:** Online e funcionando
üåê **Painel Web:** {"üü¢ Ativo" if painel_ativo else "üî¥ Inativo"}
‚ö° **Tecnologia:** Telethon + Nuvem Telegram
üóÑÔ∏è **Armazenamento:** Apenas nuvem (0% RAM local)

üõ°Ô∏è **Filtros ativos:**
‚Ä¢ Spam e divulga√ß√£o
‚Ä¢ Nomes e apelidos
‚Ä¢ Links promocionais
‚Ä¢ Termos de hack/crack

üáßüá∑ **Detec√ß√£o brasileira:**
‚Ä¢ URLs .br autom√°ticas
‚Ä¢ +50 sites nacionais .com/.net
‚Ä¢ Bancos, e-commerce, governo

üì§ **Uso:**
Digite `/adicionar` e envie seus arquivos!
    """
    
    await event.reply(stats_text)

@bot.on(events.NewMessage(pattern=r'^/cancelarupload$'))
async def cancelar_upload_handler(event):
    """Handler do comando /cancelarupload"""
    chat_id = event.chat_id
    user_id = event.sender_id
    
    logger.info(f"Comando /cancelarupload recebido de {user_id} no chat {chat_id}")
    
    if chat_id in upload_tasks and upload_tasks[chat_id]['active']:
        # Cancela uploads ativos
        upload_tasks[chat_id]['active'] = False
        
        # Limpa fila de processamento
        if chat_id in processing_queue:
            while not processing_queue[chat_id].empty():
                try:
                    processing_queue[chat_id].get_nowait()
                except asyncio.QueueEmpty:
                    break
        
        await event.reply(
            "üõë **Upload Cancelado!**\n\n"
            "‚ùå **Status:** Todos os uploads em andamento foram cancelados\n"
            "üóëÔ∏è **Fila:** Limpa e pronta para novos arquivos\n"
            "‚ôªÔ∏è **Resultados:** Dados tempor√°rios descartados\n\n"
            "‚úÖ **Pronto para novos uploads!**\n"
            "Digite `/adicionar` para recome√ßar"
        )
        
        # Limpa dados
        if chat_id in upload_tasks:
            del upload_tasks[chat_id]
        if chat_id in processing_queue:
            del processing_queue[chat_id]
            
        logger.info(f"Upload cancelado e dados limpos para chat {chat_id}")
    else:
        await event.reply(
            "‚ö†Ô∏è **Nenhum upload ativo**\n\n"
            "üìù **Status:** N√£o h√° uploads em andamento para cancelar\n"
            "üì§ **Para iniciar:** Digite `/adicionar` e envie seus arquivos"
        )

@bot.on(events.NewMessage(pattern=r'^/teste$'))
async def teste_handler(event):
    """Handler do comando /teste - para testar funcionamento"""
    await event.reply(
        "‚úÖ **Bot funcionando perfeitamente!**\n\n"
        "üîß **Teste de funcionalidades:**\n"
        "‚Ä¢ Recebimento de mensagens: ‚úÖ\n"
        "‚Ä¢ Envio de respostas: ‚úÖ\n"
        "‚Ä¢ Processamento de comandos: ‚úÖ\n\n"
        "üì§ **Para testar upload:**\n"
        "1. Digite `/adicionar`\n"
        "2. Envie um arquivo TXT pequeno\n"
        "3. Aguarde o processamento\n\n"
        "Se ainda tiver problemas, use `/help`"
    )

# ========== FUN√á√ÉO PRINCIPAL ==========

async def main():
    """Fun√ß√£o principal do bot"""
    logger.info("ü§ñ Iniciando Bot Processador Gigante 4GB com Telethon...")
    
    try:
        # Conecta ao Telegram
        if BOT_TOKEN:
            await bot.start(bot_token=BOT_TOKEN)
        else:
            logger.error("‚ùå BOT_TOKEN n√£o configurado!")
            return
            
        logger.info("‚úÖ Bot conectado! Aguardando mensagens...")
        
        # Mant√©m o bot rodando
        await bot.run_until_disconnected()
        
    except Exception as e:
        logger.error(f"‚ùå Erro no bot: {e}")
        raise

if __name__ == "__main__":
    bot.loop.run_until_complete(main())